<!DOCTYPE html><html lang="en"><head><title>clientSpec</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="clientSpec"><meta name="groc-project-path" content="test/clientSpec.js"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">test/clientSpec.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h2 id="clientspec">clientSpec</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> debug = <span class="hljs-built_in">require</span>(<span class="hljs-string">'debug'</span>)(<span class="hljs-string">'clientSpec'</span>);
<span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'chai'</span>).assert;
<span class="hljs-keyword">const</span> Broker = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mqtt-reqres-broker'</span>);
<span class="hljs-keyword">const</span> Client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/mqtt-reqres.js'</span>);

<span class="hljs-keyword">const</span> serverOptions = {
  hostname: <span class="hljs-string">'localhost'</span>,
  port: <span class="hljs-number">9999</span>
};

<span class="hljs-keyword">const</span> wsBroker = <span class="hljs-keyword">new</span> Broker();


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pcatch</span> (<span class="hljs-params">reason</span>) </span>{
  debug(reason);
  assert(!reason, reason);
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startServer</span> (<span class="hljs-params">callback</span>) </span>{

  debug(<span class="hljs-string">'startServer()'</span>);

  wsBroker.initialize(serverOptions, err =&gt; {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-built_in">console</span>.error(err.stack);
      callback(err);
    }
    <span class="hljs-keyword">else</span> {
      
      wsBroker.start(<span class="hljs-literal">null</span>, err =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-built_in">console</span>.error(err.stack);
        } 
        <span class="hljs-keyword">else</span> {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`broker running at http://<span class="hljs-subst">${wsBroker.hostname}</span>:<span class="hljs-subst">${wsBroker.port}</span>/`</span>);
        }         
        callback(err);
      });
      
    }
  });
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newClient</span> (<span class="hljs-params">clientId</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Client({
      clientId: clientId,
      brokerProtocol: <span class="hljs-string">'ws'</span>,
      brokerHostname: serverOptions.hostname,
      brokerPort: serverOptions.port
    });
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeClients</span> (<span class="hljs-params"><span class="hljs-comment">/*...connections*/</span></span>) </span>{

  <span class="hljs-keyword">const</span> clients = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>),
    pList = clients.map(client =&gt; {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span> (resolve =&gt; {
        <span class="hljs-keyword">if</span> (client) {
          client.close(resolve);
        }
      });
    });

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(pList).catch(pcatch); 
}

describe(<span class="hljs-string">'MqttReqResClient'</span>, () =&gt; {

  <span class="hljs-keyword">const</span> clientAId = <span class="hljs-string">'client-a'</span>,
    clientBId = <span class="hljs-string">'client-b'</span>,
    sharedSecret = <span class="hljs-string">'secret-a-b'</span>;
  
  <span class="hljs-keyword">var</span> clientA, 
    clientB;


  before(startServer);

  after(done =&gt; {
    wsBroker.close(done);
  });


  it(<span class="hljs-string">'should connect to broker'</span>, done =&gt; {

    assert(Client);

    clientA = newClient(clientAId);

    assert(!clientA.mqttClient || !clientA.mqttClient.connected);

    clientA.on(<span class="hljs-string">'broker-connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

      assert.isTrue(clientA.mqttClient.connected, <span class="hljs-string">'mqttClient should be connected to broker'</span>);
      assert.isTrue(clientA.subscribedConnect, <span class="hljs-string">'client should have subscribed connect topic'</span>);

      closeClients(clientA).then(() =&gt; done());
    });

    clientA.connect().catch(pcatch);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>or:
clientA.connect()
  .then(..);</p></div></div><div class="code"><div class="wrapper">  });


  it(<span class="hljs-string">'should connect to other client'</span>, done =&gt; {

    clientA = newClient(clientAId);
    clientB = newClient(clientBId);


    clientB.sharedSecret(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientId, callback</span>) </span>{
      debug(<span class="hljs-string">'clientB.sharedSecret(%s)'</span>, clientId);
      callback(clientId === clientAId ? sharedSecret : <span class="hljs-literal">null</span>);
    });


    clientB.connect()
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        debug(<span class="hljs-string">'clientB connected to broker'</span>);
        <span class="hljs-keyword">return</span> clientA.connect(clientBId, sharedSecret);
      })
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            
        <span class="hljs-keyword">var</span> connectedClients = clientA.getConnected(),
          connClientB;

        assert.strictEqual(connectedClients.length, <span class="hljs-number">1</span>);
        
        connClientB = connectedClients[<span class="hljs-number">0</span>];

        assert.strictEqual(connClientB.clientId, clientBId);

        assert.isTrue(Client.isConnected(connClientB));

        debug(<span class="hljs-string">'clientA connected to '</span> + clientBId);

        closeClients(clientA, clientB).then(() =&gt; done());
      })
      .catch(pcatch);
  });


  it(<span class="hljs-string">'should accept connection requests from other clients'</span>, done =&gt; {

    clientA = newClient(clientAId);
    clientB = newClient(clientBId);

    clientA.sharedSecret(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientId, callback</span>) </span>{
      callback(sharedSecret);
    });

    clientB.sharedSecret(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientId, callback</span>) </span>{
      callback(sharedSecret);
    });

    clientB.on(<span class="hljs-string">'client-connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientId</span>) </span>{
      
      <span class="hljs-keyword">var</span> connectedClients = clientB.getConnected(),
        connClientA = connectedClients[<span class="hljs-number">0</span>];

      assert.strictEqual(clientId, clientAId);

      assert.strictEqual(connectedClients.length, <span class="hljs-number">1</span>);

      assert.isTrue(Client.isConnected(connClientA));
      
      closeClients(clientA, clientB).then(() =&gt; done());
    });

    clientB.connect()
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>or: <code>return clientA.connect(clientBId, sharedSecret);</code></p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">return</span> clientA.connect(clientBId);
      })
      .catch(pcatch);
  });


  it(<span class="hljs-string">'should request and respond'</span>, done =&gt; {

    clientA = newClient(clientAId);

    clientA.sharedSecret(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientId, callback</span>) </span>{
      callback(sharedSecret);
    });

    clientB = newClient(clientBId);

    clientB.sharedSecret(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientId, callback</span>) </span>{
      callback(sharedSecret);
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>define request handler</p></div></div><div class="code"><div class="wrapper">    clientB.onRequest(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>{
      debug(<span class="hljs-string">'ClientB.on request'</span>, req.payload);
      assert.strictEqual(req.payload, <span class="hljs-string">'hello'</span>);
      res.send(<span class="hljs-string">'foo'</span>);
    });

    clientB.connect()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>  no need to connect clientA explicitely, will be implicitely done by clientA.request() which uses sharedSecret-handler function set before</p>
<pre><code>  .then(function () {
     return clientA.connect(clientBId, sharedSecret);
  })</code></pre></div></div><div class="code"><div class="wrapper">      
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> clientA.request(clientBId, <span class="hljs-string">'hello'</span>);
      })
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
        assert.strictEqual(res, <span class="hljs-string">'foo'</span>);
        closeClients(clientA, clientB).then(() =&gt; done());
      })
      .catch(pcatch);
  });


  it(<span class="hljs-string">'should disconnect a client'</span>, done =&gt; {

    <span class="hljs-keyword">var</span> isConnected;

    clientA = newClient(clientAId);

    clientB = newClient(clientBId);

    clientB.sharedSecret(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientId, callback</span>) </span>{
      callback(sharedSecret);
    });

    isConnected = Client.isConnected(clientA.getConnection(clientBId));

    assert.isFalse(isConnected);

    clientB.connect()
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> clientA.connect(clientBId, sharedSecret);
      })
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        isConnected = Client.isConnected(clientA.getConnection(clientBId));

        assert.isTrue(isConnected);

        <span class="hljs-keyword">return</span> clientA.disconnect(clientBId);
      })
      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{

        isConnected = Client.isConnected(clientA.getConnection(clientBId));
        assert.isFalse(isConnected);

        closeClients(clientA, clientB).then(() =&gt; done());
      })
      .catch(pcatch);
  });

});</div></div></div></div></body></html>